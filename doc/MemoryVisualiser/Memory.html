<!DOCTYPE html>
<html>
  <head>
    <script src="http://d3js.org/d3.v2.js"></script>
		<script type="text/javascript" >
var names=[], sizes=[];
var svgWidth= 600,svgHeight = 1800;
var width=10, height=width;
var rowPadding =width/5;
var colPadding =1;
var numOfCircs=4;
var divider =3;
var biggestShare = (width/divider)/numOfCircs; // share each circle gets
var r = biggestShare/numOfCircs;
var circleArea = width/divider;
var firstSVG;
var pageSizes =[];

function createVisual(){
	var everything = readFile("PercentPage");
  var biggerFont = (width/4)+10;
  var recSelect  =[], recSelectText=[];
  var onClick = function(theText, theRect){
                  var obj = theRect;
                  if(theRect.attr("stroke")=="#eee9e9"){
                    if(recSelect.length ==2){
                       var lastObj = recSelect.pop(); // take off the first one
                       lastObj.attr("stroke", "#eee9e9");
                       lastObj = recSelectText.pop(); // take off the first one
                       lastObj.attr("stroke", "#eee9e9");
                       lastObj.text("Click to select");
			              }
                    theText.attr("stroke", "blue");
                    theText.text("Click to unselect");
                    theRect.attr("stroke", "blue");
                    recSelect.push(theRect);
                    recSelectText.push(theText);
		              }
                  else{
                    var ind = -1
                    var id = obj.attr("id");
                    for(var i=0; i < recSelect.length; i++){
                      if(id == recSelect[i].attr("id")){
                        ind = i;
                        break;
                      }
                    }
                    theText.attr("stroke", "#eee9e9");
                    theText.text("Click to select");
                    theRect.attr("stroke", "#eee9e9");
                    recSelect.splice(ind, 1);
                    recSelectText.splice(ind, 1);
	                }
                }
  var submit = function(){
                 if(recSelect.length != 2)return;
                   compare(recSelect, everything, false);
	             }

	for(var k=0; k < everything.length;k++){
    // create divs to anchor svg to
  	var div = document.createElement('div');
		div.setAttribute('id','table'+k);
		document.getElementsByTagName('body')[0].appendChild(div);
 		var newP = document.createElement("p");
    newP.appendChild(document.createTextNode(names[k]));
    var newP2 = document.createElement("p");
    newP2.appendChild(document.createTextNode(sizes[k]));
    div.appendChild(newP);
    div.appendChild(newP2);
    // create svg
		var svg = d3.select("#table"+k).selectAll("svg")
     					.data(d3.range(0, 1))			
   						.enter().append("svg")
     					.attr("width", svgWidth+(biggerFont*4)+600)
     					.attr("height", svgHeight)
     					.attr("id","svg"+k)
              .style("background-color","white")
		 					.attr("class",function(d){return d;});
    var svgRect = svg.append("rect")
                  .attr("id", "#re-"+k)
                  .attr("x",1)
                  .attr("y",1)
                  .attr("width", svgWidth-1)
                  .attr("height", svgHeight-2)
                  .on("click", function(d,i){
                                 var id = d3.select(this).attr("id");
                                 var textID = "#txt-"+id.split("-")[1];
                                 var children = this.parentNode.childNodes
                                 for(var i=0; i < children.length; i++){
                                   if(d3.select(children[i]).attr("id")== textID){
                                     onClick(d3.select(children[i]),d3.select(this));
                                   }
                                 }
                               })
                  .attr("cursor", "pointer")
                  .attr("stroke", "#eee9e9")
                  .attr("fill", "white")
                  .attr("opacity","1");
    svg.append("text")
       .attr("dx", 1)
       .attr("id", "#txt-"+k)
         .attr("dy", 10)
         .attr("font-size", 12)
         .attr("stroke", "grey")
         .style("font-family", "Courier New, Times, serif")
         .attr("kernel", "50%")
         .attr("cursor", "pointer")
         .on("click", function(d,i){
                        var id = d3.select(this).attr("id");             
                        var rectID = "#re-"+id.split("-")[1];
                        var children = this.parentNode.childNodes
                        for(var i=0; i < children.length; i++){
                          if(d3.select(children[i]).attr("id")== rectID){
                            onClick(d3.select(this),d3.select(children[i]));
                          }
                        } 
                      })
         .text("Click to select");
    if(k==0){
      firstSVG = svg;
      // only want one button
		  svg.append("rect")
         .attr("x",650)
         .attr("y",20)
         .attr("rx",7)
         .attr("ry",7)
         .attr("width",70)
         .attr("height",25)
         .attr("fill", "white")
         .style("fill", "grey")
         .attr("cursor", "pointer")
         .on("click", submit);
      svg.append("text")
         .attr("dx", 660)
         .attr("dy", 35)
         .attr("font-size", 12)
         .attr("stroke", "white")
         .style("font-family", "Courier New, Times, serif")
         .attr("kernel", "50%")
         .attr("cursor", "pointer")
         .on("click", submit)
         .text("compare");
		}
		var end = addRec(svg, everything, k, 0, "first"+k, svgWidth, false, 7);
    var endHeight = end[1] +height;
    if(endHeight < 100)endHeight=100;
    svg.attr("height", endHeight);
    svgRect.attr("height", endHeight-2);
    // add another rectangle which has the name
    svg.append("text")
       .attr("dx",end[0])
       .attr("dy", end[1])
       .attr("font-size", 12)
       .text(end[2].toString(16));

   
  }
}

/*
 Functions for highlighting individual pages.
*/
var highlight = function(obj) {
  // make outline grey
	var rect = d3.select(obj.parentNode.childNodes[0]);
	oldCol= rect.attr("stroke");
	rect.attr("stroke","grey");
}
var unhighlight = function(obj) {
  var rect = d3.select(obj.parentNode.childNodes[0]);
	rect.attr("stroke",oldCol);
}

/*
Adds the rectangles representing each page.
*/
function addRec(svg, everything, k, start, id, svgWidthy, sign, yOffset){
  start = start +4;
 	var x = (start-width), y = rowPadding+10 +yOffset;
	var circs =[];
	var tmpY = y;
  // create a group node.
  var flip= new Array();
  var addCircleWidth = false;
	var nodes = svg.selectAll(".node"+id)
    	           .data(everything[k]).enter().append("g")
    	           .attr("class", "node")
                 .attr("id", "IDnode"+id);
  // add rectangles to group
  var pageNum=0,endXPos =0, endYPos=0;
  var rec= nodes.append("rect")
                .attr("id",function(d,i){return "rect"+i;})
 								.attr("x", 
                      function(d,i){
                        var subs= d.split(".");
                        if(addCircleWidth){x += circleArea+colPadding;}
												else x+=width+colPadding;
                        
     										if(x >= svgWidthy-width){
                          x =start; 
													tmpY = tmpY + height+rowPadding;
                          flip.push(i);
												}
                        addCircleWidth = false;
    										if(subs.length >1 && parseInt(subs[1])>1 ){
    										  var oldX = x;
    											x = x +(width)+colPadding;// x is where it starts
                          endXPos =x;
    											var amountLeft = (biggestShare -(r*2));
    											var cx = x + (amountLeft/2)+ r; // amountLeft should be halved as half goes before circle and half after.
            			         								                // need to add r as cx is middle of circle.
    											var end = (x + biggestShare)- r; // end of area that circles share.

    											var cy = tmpY + (height/2);
                          if(cx+circleArea+colPadding> svgWidthy){
                            cx = start+ (amountLeft/2)+r; // this at the start
                            end = (start+biggestShare) -r;
                            cy= cy+height+rowPadding;
                            endYPos = cy;
                            x =start; 
														tmpY = tmpY + height+rowPadding;
                            flip.push(i+1);
													}
    											for(var k=0; k < numOfCircs; k++){   
    											  circs.push([cx, cy]);
    												cx = end + amountLeft + r;
                            endXPos =cx;
    												end = end+ biggestShare;
													} 
                          addCircleWidth = true;
    										  return oldX;   
												}
                        endXPos =x;
                        
												return x;
											})
		  					.attr("y",
                      function(d,i){
												if(flip.indexOf(i)>-1){
												  y =y + height+rowPadding;
												}
                        if(y > endYPos){
                          
                          endYPos = y+(height/2); 
                        }
												return y;
											})
    						.attr("class",
                      function(d) {
        							  var subs= d.split(".");
												var num = subs[0];
												if(num == 100){
												  var first = "10";
												}
												else if ( num > 9){		
												  var first = num.substring(0,1);
                        } 
												else if(num > 0){
												  var first = "0";
												}
												else if(num == 0){
												  var first = "00";
												}
												else if (-10 < num && num< 0){
												  var first = "-1";
												}
                        else if (num==-100){
												  var first = "-10";
												}
                        else if (-10  >= num){
												  var first = num.substring(0,2);
												}
												return "c-"+first;
											})
   							.attr("width", width)
   							.attr("height", height)
                .on("mouseover", function(d,i){highlight(this);})
    						.on("mouseout", function(d,i){unhighlight(this);})
   							.attr("title",
                      function(d) {
                        var tempPageNum=pageNum; 
                        var subs= d.split(".");
												if(subs.length >1 && parseInt(subs[1])>1){
          							  pageNum= pageNum + parseInt(subs[1]);
      									}
      									else{
       									  pageNum++;
												}
                        var n = subs[0];
                        if(n>0 && sign){
	                        return "+"+n+"% \n "+tempPageNum.toString(16);
												}
												return n+"% \n"+tempPageNum.toString(16);
											});
  var result = width/(r*r);

  // add circles for indicating compressed data
	svg.selectAll("circle"+id)
     .data(circs)
     .enter().append("circle")
     .attr("class", "here")
     .attr("cx", function(d){return d[0];})
     .attr("cy", function(d){return d[1];})
     .attr("r", r)
     .attr("stroke", "grey")
     .attr("fill", "white");
    return [endXPos+width,endYPos,pageNum];

}
/*
Reads the file and transforms the data into a double array.
Each line in file is changed into a number percent+.+numberofentries
10318,28 
10318,28
-> [0.10318,28.0,28.0]
*/
function readFile(theName) {
	xmlhttp = new XMLHttpRequest();
	xmlhttp.overrideMimeType('text/plain');
  xmlhttp.open("GET",theName,false);
  xmlhttp.send(null); 
  var allFilePages = xmlhttp.responseText.split('\n\n');
  var list=[];
  for (var i=0; i < allFilePages.length;i++){
  	var eachFilePages = allFilePages[i].split('\n');
		var li=[];
		var number = 1;//number of ones that have the same percent
    var nextPageNum=0;
		var last = -1;//the percent of last one
    var flatten = false;
    var full =0;
    if(eachFilePages.length> 2){ // take flatten out?
			flatten = true;
		}
    if(eachFilePages.length>1){ 
      var size = eachFilePages.length -2
      pageSizes.push(eachFilePages[1]);
			var theName= eachFilePages[0]+" "+ eachFilePages[1]+"KB Pages.";
    	names.push(theName);
      var flattenEffect=0;
    	for(var j=2; j < eachFilePages.length;j++){
      	if(eachFilePages[j].length==0) continue;
  			var pageInfo = eachFilePages[j].split(',');
   	  	var pageNumber = parseInt(pageInfo[0], 16);
      	var percentFull = pageInfo[1];
        full += parseInt(percentFull);
      	if(j==2 && pageNumber > nextPageNum){
			 		li.push("0."+(pageNumber-nextPageNum));
				}
				if(flatten && percentFull == last && pageNumber==nextPageNum){
          flattenEffect++;
					number++;
        	nextPageNum++;
				}
				else{
					// not equal so add previous to list
        	if(last>0){
        		theName= last+"."+number;
						li.push(""+theName);
          	if(pageNumber !=nextPageNum){
            	var num = pageNumber - nextPageNum;
							li.push("0."+num);
        		}
					}
        	last = percentFull;
					number =1;
					nextPageNum= pageNumber;
        	nextPageNum++;
				}
			}

    var pFull= parseInt(full/size);
    var theSize = " Memory is over "+ size +" pages. Average % full = "+pFull+".";
    sizes.push(theSize);
		// do any left over
		li.push(last+"."+number);
		list.push(li);

    }
	}
  return list;
}

function todo(isX,stillToDo, origX1orY1,oppX1orY1,origX2orY2, changedX2orY2, percent){
  smallest = changedX2orY2;
  // shouldnt i do the first point anyway?
  if(origX2orY2 < smallest){ // if y2 < x2
    // smalest is bigger than orginal.
    newPoints.push(percent+"."+origX2orY2);
    if(stillToDo.length==0){
      stillToDo.push(oppX1orY1);
      stillToDo.push(smallest- origX2orY2);
      return !isX;
    }
    smallest = changedX2orY2;
    var done = true;
    var len = stillToDo/2;
    for(var p=0; p < len; p++){
      done=false;
			var newPercent= stillToDo.shift(); //newX1
      var newAmount = stillToDo.shift();	// newX2
      if(isX){
			  percent= oppX1orY1-newPercent; // or newPercent- x1
      }
      else percent = newPercent - oppX1orY1;
      //for this just want to find the smallest, no? 
      smallest= changedX2orY2;
      if(newAmount < smallest) smallest= newnewAmount;
			newPoints.push(percent+"."+smallest);
      changedX2orY2 = changedX2orY2-smallest; // nowX2 = nowX2 - smallest
      if(changedX2orY2 ==0){ // if nowX2 ==0
			  done= true;
        if(newAmount!= smallest){
          stillToDo.push(newPercent);
          stillToDo.push(newAmount-smallest);
				}
        break;
			}
		}
    return isX;
  }
  else{
    newPoints.push(percent+"."+smallest);
    stillToDo.push(origX1orY1);
    stillToDo.push(origX2orY2 - smallest);
    return isX;
  }
}
var isX= false;
var newPoints=[];

function reconfigurePageSize(changedOne, offset, oppOffset){
  var len = changedOne.length;
  var updated =[];
  var waitingPer =[];
  var waitingPages =[];
  if(changedOne[0].split(".")[0]==0 && changedOne[0].split(".")[1] > oppOffset){
    var first = changedOne.shift().split(".");
    var after = parseInt(first[1])*offset;
    updated.push("0."+ Math.round(after));

  }
  while(changedOne.length >0 || waitingPer.length >0){
      // need as many pages to merge as oppOffset
      var percent = 0;
      var howManyPages = 0;
      if(waitingPer.length >0){
        // do this first
        var waitingLen = waitingPer.length;
        for(var p=0; p < waitingLen; p++){
          per = waitingPer.shift();
          howMany= waitingPages.shift();
          if(howMany+ howManyPages == oppOffset){
            // good
            howManyPages = oppOffset;
            percent += (per * howMany);
            break;
          }
          if(howMany+ howManyPages > oppOffset){
            // take what we need, push back onto waiting
            var whatsUsed = (oppOffset - howMany);
            var whatsLeft = howManyPages - whatsUsed;
            waitingPer.unshift(per);
            waitingPages.unshift(whatsLeft);
            //now found everything i need
            howManyPages = oppOffset;
            percent += (per * whatsUsed);
            break;
            
          }
          if(howMany+ howManyPages < oppOffset){
            //we can keep looping
            howManyPages +=howMany;
            // need to know how many percents im adding.
            percent += (per * howMany);
          }
        }
      }
      while (changedOne.length >0 && howManyPages != oppOffset){
        // keep adding to percent and how many pages
        var y = (changedOne.shift()).split(".");
        var whatUsed = parseInt(y[1]);
        if(whatUsed+ howManyPages > oppOffset){ 
          // we don need all of y
          // we only want some of the y then
          restOfY = whatUsed - (oppOffset- howManyPages); // whats left of y
          per = parseInt(y[0]); // the percent
          whatUsed = parseInt(y[1]) - restOfY; // what we took from y
          // still need to store whats left
          waitingPer.push(per);
          waitingPages.push(restOfY);

        }
        percent += (parseInt(y[0])*whatUsed); // times percent by whatUsed
        howManyPages +=whatUsed;
      }
      // have all percent we need and all pages together we need
      actualPercent = percent*offset;
      updated.push(Math.round(actualPercent)+".1");
    }
 return updated;
}
function compare(objs, everything, test){
  newPoints=[],stillToDo=[];
  var obj1 = everything[objs[0].attr("id").split("-")[1]].slice(0);
  var obj2 = everything[objs[1].attr("id").split("-")[1]].slice(0);
  var pageSize1 = pageSizes[objs[0].attr("id").split("-")[1]];
  var pageSize2 = pageSizes[objs[1].attr("id").split("-")[1]];
  // are they the same page size?
  if(pageSize1 != pageSize2){
    if(pageSize1 > pageSize2){
      var offset = pageSize2/pageSize1;
      var oppOffset = pageSize1/pageSize2;
      var changedOne = obj2;
    }
    else{
      var offset = pageSize1/pageSize2;
      var oppOffset = pageSize2/pageSize1;
      var changedOne = obj1;
    }
    updated = reconfigurePageSize(changedOne, offset,oppOffset );
    if(pageSize1 >pageSize2) obj2 = updated;
    else obj1=updated;
  }
  var first = obj1;
  var sec = obj2;
  // always compare the first result with next result.
  if(objs[0].attr("id") > objs[1].attr("id")){
    var first = obj2;
    var sec = obj1;
  }

  // loop around the first objects first
  // compare each against the sec object.
  var firstBigger = first.length - sec.length;
	stillToDo = doLoop(first, sec);
  if(firstBigger < 0){ 
		// then the rest of the new points is just sec.
    if(!isX){
      // also need to do the rest of the sec? or it's okay as that's done after?
      var leng = stillToDo.length;
      for(var j=0; j < leng; j=j+2){
			  // just push it.
        // its not from the first one
        newPoints.push(stillToDo.shift()+"."+stillToDo.shift());
      }
    }
    else{
      //isX in stillToDo
      var leng = stillToDo.length;
      fi =[];
      //se = sec.splice(first.length); // maybe not needed.
      for(var j=0; j <= (leng)/2; j++){
        fi.push(stillToDo.shift()+"."+stillToDo.shift())
      }
      stillToDo=[];
      stillToDo = doLoop(fi, sec);
    }// else
    var len = sec.length
    for(var q=0; q < len; q++){ // TODO and make sure the sec only has the stuff we still need to do.
      // do the rest of the sec.
      newPoints.push(sec.shift());
    }
	}// if
  if(stillToDo.length >0){
  for(var i=0; i <= (stillToDo.length)/2; i++){
    if(isX)
      newPoints.push("-"+stillToDo.shift()+"."+ stillToDo.shift());
    else
      newPoints.push(stillToDo.shift()+"."+ stillToDo.shift());
  }
}
  // make the rectangle
  if(test){
    return newPoints;
  }
  var theSVG= d3.selectAll("#svg0");
  var temp = theSVG.append("g").attr("id", "extra")
  var start=750;

  var thing = document.getElementById("extra");
  if(thing){
    var fc = thing.firstChild;
    if(fc != null){
      while(fc) {
        thing.removeChild( fc );
        fc = thing.firstChild;
      }
    }
  }
  var end = addRec(temp, [newPoints], 0, 750, "sec", 1200, true, 7);
  var endHeight = end[1] +height;
  if(endHeight < 100)endHeight=100;
  firstSVG.attr("height", endHeight);
  // add another rectangle which has the name
  temp.append("text")
     .attr("dx",end[0])
     .attr("dy", end[1])
     .attr("font-size", 12)
     .text(end[2].toString(16));
}

function doLoop(first, sec){
  var loopNumber = first.length // added so we have a definite loop number that wont change.
  for(var i=0; i <loopNumber; i++){
    var xUnsplit = first.shift().split("."); // added
    var x1 = parseInt(xUnsplit[0]); // the percent
    var x2 = parseInt(xUnsplit[1]); // how many pages the percent is over
    if(i >= sec.length){ 
      // nothing left to compare with in other file.
      if(stillToDo.length >0){
        if(!isX){
          for(var p=0; p < stillToDo.length; p++){
            var pC2 =  parseInt(stillToDo.shift());
            var num2 =  parseInt(stillToDo.shift());
            // need to compare with the first one
            var diff = pC2 - x1;
            breakOut= false;
            if(x2 >= num2){
              var howMany = num2;
              x2 = x2 - num2;
              if(x2 ==0)breakOut = true;
              testPaths(4);
            }
            else{
              var howMany = x2;
              stillToDo.unshift(pC2,num2-x2);
              x2 = 0, x1 = 0;
              // if this isn't the last one in first file, we want next one in first file.
              if(i!=first.length-1)breakOut = true;
            }
            newPoints.push(diff+"."+howMany);
            if(breakOut){testPaths(6);break;}
          }
          continue;
        }
        else{ //isX
          // okay can loop around stillToDo and then do this first one
          for(var p=0; p < stillToDo.length; p++){
            var pC = stillToDo.shift();
            var num= stillToDo.shift();
            newPoints.push("-"+pC+"."+num);
          }
        }
      }
      // do the current first one
      // since at this point there is nothing to compare with
      // stillToDo has nothing and nether does the sec.
      newPoints.push("-"+x1+"."+x2);
      continue;
    }
    var yUnsplit = sec.shift().split("."); // added.    
    var y1 = parseInt(yUnsplit[0]); // the percent
    var y2 = parseInt(yUnsplit[1]); // how many pages the percent is over
          
    if(stillToDo.length==0){
		  // both at same point so far (at same pageNumber)
      // can compare normally
      var diff = y1-x1;
      if(x2==y2){
			  // the pages the percents is over is the same
        newPoints.push(diff+"."+x2);
        continue;
			}
      // the num of pages the percent is over is different
      // so its the same for a couple, but not for all.
			var leftOver = x2-y2;
      var smallest = y2;
      isX = true;
      re = x1;
      if (x2< y2){
        smallest=x2;
        re = y1;
        isX= false;
      }
      newPoints.push(diff+"."+smallest);
      // still need to store the bit left over.
      stillToDo.push(re);
      stillToDo.push(Math.abs(leftOver));
      continue;
		}
		// okay so something has been left over.
    if(isX){ // in stillToDO is the x value
		  var theX1 = stillToDo.shift();
      var theX2 = stillToDo.shift();
      var theY1= y1,theY2 = y2;
		}
		else{ // in stillToDO is the y value
		  var theX1 = x1,theX2 = x2;
      var theY1=stillToDo.shift();;
      var theY2 = stillToDo.shift();;
		}
		if(theX2 == theY2){
      //both for the same amount
		  newPoints.push(theY1-theX1+"."+theY2);
      // now do the next one
			if(isX){
			  stillToDo.push(x1);
        stillToDo.push(x2);
			}
			else{
			  stillToDo.push(y1);
        stillToDo.push(y2);
        isX=false;
			}
     continue;
		}
    // merge these together
    if(isX && theX2 > theY2){
		  // so this one is bigger than y2, so some of it will be saved as will x2
      var percent =  y1 - theX1;
      newPoints.push(percent+"."+y2);
      stillToDo.unshift(theX2 - y2);
      stillToDo.unshift(theX1); // wait this came off the front, so i want it to go back in front
      isX = true;
      // also need to push x1 
      stillToDo.push(x1);
      stillToDo.push(x2);
		}
    else if(!isX && theY2 > theX2){
		  var percent =  theY1 - theX1;
      newPoints.push(percent+"."+theX2);
      stillToDo.unshift(theY2 - theX2);
      stillToDo.unshift(theY1); // wait this came off the front, so i want it to go back in front
      isX = false;
      // also need to push x1 
      stillToDo.push(y1);
      stillToDo.push(y2);
		}
    else{
      testPaths(21);
		  // y2 is bigger than firstX2
      // so add diff between it and firstx then do x1
      var percent = theY1 - theX1;
      // this depends on what is the extra one.
      if(isX){
        testPaths(22);
        // so y2 is bigger than firstX2
        newPoints.push(percent+"."+theX2);
				var nowY2 = theY2-theX2;
        // now x1 
        percent = y1- x1;
        var smallest = nowY2;
        if(nowY2 == x2){
         newPoints.push(percent+"."+x2);
         continue;
        }
       isX= todo(isX,stillToDo, x1,y1,x2, nowY2, percent);
			}// is X
      else{
        //Not X
        // theY2 is bigger than x2
				newPoints.push(percent+"."+theY2);
        var nowX2 = theX2- theY2;// it will never be 0.
        // now use previous y1 to compare
        percent = y1- x1;
        if(nowX2 == y2){
         newPoints.push(percent+"."+y2);
         continue;
        }
        // if the one opposite from whats in stillTODO so here what's in x
        // if x2 is bigger than the y2 then we loop around stillToDo. 
        isX= todo(isX,stillToDo, y1,x1,y2, nowX2, percent);

			}// other else
		}	// other else
	} // for loop
return stillToDo;
}




</script>
		<!link rel="stylesheet" type="text/css" href="colours.css" />
   <style>
/* 0% full*/
.c-00 {
	fill:rgb(240,265,240);
}
.c-0 {
	fill:rgb(220,265,220);
}
.c-1 {
	fill:rgb(193,265,193);
}
.c-2 {
	fill:rgb(180,248,180);
}
.c-3 {
	fill:rgb(150,230,150);
}
.c-4 {
	fill:rgb(100,210,100);
}
/* 50% full */
.c-5 {
	fill:rgb(50,180,50);
}
.c-6 {
	fill:rgb(20,160,20);
}
.c-7 {
	fill:rgb(10,142,10);
}
.c-8 {
	fill:rgb(10,120,10);
}
.c-9 {
	fill:rgb(0,100,10);
}
/* 100% full*/
.c-10 {
	fill:rgb(0,90,0);
}
.c--1{
	fill:rgb(265,250,250);
}
.c--2{
	fill:rgb(265,240,240);
}
.c--3{
	fill:rgb(265,220,220);
}
.c--4{
	fill:rgb(265,200,200);
}
.c--5{
	fill:rgb(265,170,170);
}
.c--6{
	fill:rgb(265,140,140);
}
.c--7{
	fill:rgb(265,120,120);
}
.c--8{
	fill:rgb(265,80,80);
}
.c--9{
	fill:rgb(265,50,50);
}
.c--10{
	fill:rgb(265,0,0);
}
  </style>
	</head>
	<body>
		<script type='text/javascript'>
			createVisual();
		</script>
  </body>
</html>
